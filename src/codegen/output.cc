#include <assert.h>
#include <ctype.h>
#include <stdio.h>
#include <time.h>
#include <iomanip>

#include "config.h"
#include "src/codegen/emit.h"
#include "src/codegen/input_api.h"
#include "src/codegen/output.h"
#include "src/codegen/print.h"
#include "src/msg/msg.h"
#include "src/msg/warn.h"
#include "src/options/opt.h"
#include "src/encoding/enc.h"
#include "src/util/string_utils.h"
#include "src/util/temp_file.h"
#include "src/util/uniq_vector.h"


namespace re2c {

static uint32_t count_lines_text(const char *text)
{
    DASSERT(text);
    uint32_t lc = 0;
    for (const char *s = text; *s; ++s) {
        if (*s == '\n') ++lc;
    }
    return lc;
}

static uint32_t write_converting_newlines(const std::string &str, FILE *f)
{
    const char *s = str.c_str(), *e = s + str.length();
    uint32_t lines = 0;

    // In order to maintain consistency we convert all newlines to LF when
    // writing output to file. Some newlines originate in user-defined code
    // (including semantic actions and code fragments in configurations and
    // directives), and some are generated by re2c itself.
    for (const char *p = s;; ++p) {
        size_t l = static_cast<size_t>(p - s);
        if (p == e) {
            fwrite(s, 1, l, f);
            break;
        } else if (*p == '\n') {
            ++lines;
            if (p > s && p[-1] == '\r') --l;
            fwrite(s, 1, l, f);
            s = p;
        }
    }

    return lines;
}

OutputBlock::OutputBlock(const loc_t &loc)
    : loc(loc)
    , fragments ()
    , used_yyaccept (false)
    , have_user_code (false)
    , types ()
    , stags ()
    , mtags ()
    , opts(NULL)
{}

OutputBlock::~OutputBlock ()
{
    delete opts;
}

Output::Output(Msg &msg)
    : cblocks()
    , hblocks()
    , pblocks(&cblocks)
    , label_counter()
    , fill_index(0)
    , state_goto(false)
    , cond_enum_in_hdr(false)
    , cond_goto(false)
    , warn_condition_order(true)
    , need_header(false)
    , msg(msg)
    , skeletons()
    , max_fill(1)
    , max_nmatch(1)
    , allocator()
    , scratchbuf(allocator)
{}

Output::~Output ()
{
    for (uint32_t i = 0; i < cblocks.size(); ++i) delete cblocks[i];
    for (uint32_t i = 0; i < hblocks.size(); ++i) delete hblocks[i];
}

void Output::header_mode(bool on)
{
    pblocks = on ? &hblocks : &cblocks;
}

bool Output::in_header() const
{
    return pblocks == &hblocks;
}

OutputBlock& Output::block()
{
    return *pblocks->back();
}

size_t Output::blockid() const
{
    return (in_header() ? hblocks.size() : cblocks.size()) - 1;
}

void Output::wraw(const char *s, const char *e)
{
    if (s != e && block().opts->target == TARGET_CODE) {
        // scan for non-whitespace characters
        bool &code = block().have_user_code;
        for (const char *p = s; !code && p < e; ++p) {
            code = !isspace(*p);
        }
        wdelay_stmt(0, code_raw(allocator, s, static_cast<size_t>(e - s)));
    }
}

void Output::wversion_time()
{
    output_version_time(scratchbuf.stream(), block().opts->version, !block().opts->bNoGenerationDate);
    wdelay_stmt(0, code_stmt_textraw(allocator, scratchbuf.flush()));
}

void Output::wdelay_stmt(uint32_t ind, CodeStmt *stmt)
{
    OutputFragment f = {stmt, ind};
    block().fragments.push_back(f);
}

void Output::new_block(Opt &opts, const loc_t &loc)
{
    OutputBlock *b = new OutputBlock(loc);
    b->opts = opts.snapshot();
    pblocks->push_back(b);

    // start label hapens to be the only option
    // that must be reset for each new block
    opts.reset_startlabel();
}

static void fix_first_block_opts(blocks_t &blocks)
{
    // If the initial block contains only whitespace and no user code,
    // then re2c options specified in the first re2c block are also
    // applied to the initial block.
    if (blocks.size() >= 2) {
        OutputBlock *fst = blocks[0], *snd = blocks[1];
        if (!fst->have_user_code) {
            *const_cast<opt_t *>(fst->opts) = *snd->opts;
        }
    }
}

bool Output::emit_blocks(const std::string &fname, blocks_t &blocks,
    const uniq_vector_t<std::string> &global_types,
    const std::set<std::string> &global_stags,
    const std::set<std::string> &global_mtags)
{
    FILE *file = NULL, *temp = NULL;
    std::string filename = fname, tempname = fname;

    if (filename.empty()) {
        filename = "<stdout>";
        file = stdout;
    }
    else if ((temp = temp_file(tempname))) {
        file = temp;
    }
    else if (!(file = fopen(filename.c_str(), "w"))) {
        error("cannot open output file %s", filename.c_str());
        return false;
    }

    fix_first_block_opts(blocks);

    // global options are last block's options
    const opt_t *globopt = block().opts;

    unsigned int line_count = 1;
    for (unsigned int j = 0; j < blocks.size(); ++j) {
        OutputBlock & b = *blocks[j];
        const opt_t *bopt = b.opts;

        CodegenContext gctx =
            { allocator
            , scratchbuf
            , globopt
            , bopt
            , msg
            , b.loc
            , global_types
            , global_stags
            , global_mtags
            , b.types
            , max_fill
            , max_nmatch
            , fill_index
            , b.used_yyaccept
            , warn_condition_order
            };

        const size_t n = b.fragments.size();
        for (size_t i = 0; i < n; ++i) {
            OutputFragment &f = b.fragments[i];
            std::ostringstream os;

            RenderContext rctx =
                { os
                , bopt
                , msg
                , f.indent
                , filename.c_str()
                , line_count
                };

            combine_stmt(gctx, f.stmt);
            render_code_stmt(rctx, f.stmt);
            write_converting_newlines(os.str(), file);
        }
    }

    fclose(file);
    if (temp && !overwrite_file(tempname.c_str(), fname.c_str())) {
        error("cannot rename or write temporary file %s to output file %s"
            , tempname.c_str(), fname.c_str());
        remove(tempname.c_str());
        return false;
    }
    return true;
}

static void gen_cond_enum(Scratchbuf &o, code_alc_t &alc, CodeStmt *code,
    const opt_t *opts, const uniq_vector_t<std::string> &condnames)
{
    if (opts->target != TARGET_CODE) {
        code->kind = CodeStmt::EMPTY;
        return;
    }

    CodeStmts *stmts = code_stmts(alc);

    o.cstr("enum ").str(opts->yycondtype).cstr(" {");
    append_stmt(stmts, code_stmt_text(alc, o.flush()));

    CodeStmts *block = code_stmts(alc);
    for (size_t i = 0; i < condnames.size(); ++i) {
        o.str(opts->condEnumPrefix).str(condnames[i]).cstr(",");
        append_stmt(block, code_stmt_text(alc, o.flush()));
    }
    append_stmt(stmts, code_block(alc, block, CodeBlock::INDENTED));

    o.cstr("};");
    append_stmt(stmts, code_stmt_text(alc, o.flush()));

    code->kind = CodeStmt::BLOCK;
    code->block.stmts = stmts;
    code->block.fmt = CodeBlock::RAW;
}

static void add_symbols(const OutputBlock &block,
    uniq_vector_t<std::string> &conds,
    std::set<std::string> &stags,
    std::set<std::string> &mtags)
{
    const std::vector<std::string> &cs = block.types;
    for (size_t j = 0; j < cs.size(); ++j) {
        conds.find_or_add(cs[j]);
    }

    const std::set<std::string> &st = block.stags, &mt = block.mtags;
    stags.insert(st.begin(), st.end());
    mtags.insert(mt.begin(), mt.end());
}

bool Output::emit()
{
    if (msg.warn.error()) return false;

    // gather global lists of conditions and tags
    uniq_vector_t<std::string> conds;
    std::set<std::string> stags, mtags;
    for (uint32_t i = 0; i < cblocks.size(); ++i) {
        add_symbols (*cblocks[i], conds, stags, mtags);
    }
    for (uint32_t i = 0; i < hblocks.size(); ++i) {
        add_symbols (*hblocks[i], conds, stags, mtags);
    }

    // global options are last block's options
    const opt_t *opts = block().opts;
    bool ok = true;

    // emit .h file
    if (!opts->header_file.empty() || need_header) {
        // old-style -t, --type-headers usage implies condition generation
        if (!conds.empty() && !this->cond_enum_in_hdr) {
            header_mode(true);

            wdelay_stmt(0, code_stmt_textraw(allocator, ""));

            CodeStmt *code = code_stmt(allocator, CodeStmt::EMPTY);
            gen_cond_enum(scratchbuf, allocator, code, opts, conds);
            wdelay_stmt(0, code);

            header_mode(false);
        }

        ok &= emit_blocks(opts->header_file, hblocks, conds, stags, mtags);
    }

    // emit .c file
    ok &= emit_blocks(opts->output_file, cblocks, conds, stags, mtags);

    return ok;
}

void gen_tags(Scratchbuf &o, CodeStmt *code, const std::set<std::string> &tags)
{
    DASSERT(code->kind == CodeStmt::STAGS || code->kind == CodeStmt::MTAGS);

    const char *fmt = code->tags.fmt;
    const char *sep = code->tags.sep;

    std::set<std::string>::const_iterator tag = tags.begin(), end = tags.end();
    for (; tag != end; ) {
        std::string fmtstr = fmt;
        strrreplace(fmtstr, "@@", *tag);
        o.str(fmtstr);
        if (++tag == end) break;
        o.cstr(sep);
    }
    code->text = o.flush();
    code->kind = CodeStmt::VERBATIM;
}

static void gen_state_goto(Scratchbuf &o, code_alc_t &alc, CodeStmt *code,
    uint32_t start_label, uint32_t fill_index, const opt_t *opts)
{
    o.str(opts->state_get).cstr(opts->state_get_naked ? "" : "()");
    CodeText expr = o.flush();

    CodeStmts *goto_start = code_stmts(alc);
    o.cstr("goto ").str(opts->labelPrefix).u32(start_label).cstr(";");
    append_stmt(goto_start, code_stmt_text(alc, o.flush()));

    CodeCases *ccases = code_cases(alc);
    if (opts->bUseStateAbort) {
        // default: abort();
        CodeStmts *abort = code_stmts(alc);
        append_stmt(abort, code_stmt_text(alc, "abort();"));
        append_case(ccases, code_case_default(alc, abort));

        // case -1: goto <start label>;
        append_case(ccases, code_case_number(alc, goto_start, -1));
    }
    else {
        // default: goto <start label>;
        append_case(ccases, code_case_default(alc, goto_start));
    }
    for (uint32_t i = 0; i < fill_index; ++i) {
        CodeStmts *stmts = code_stmts(alc);

        if (opts->eof != NOEOF) {
            // TODO: render this as a separate statement
            o.cstr("if (").str(output_expr_lessthan(1, opts)).cstr(")")
                .cstr(" goto ").str(opts->labelPrefix).cstr("eof").u32(i).cstr("; ");
        }
        o.cstr("goto ").str(opts->yyfilllabel).u32(i).cstr(";");
        append_stmt(stmts, code_stmt_text(alc, o.flush()));

        append_case(ccases, code_case_number(alc, stmts, static_cast<int32_t>(i)));
    }

    CodeStmts *stmts = code_stmts(alc);
    append_stmt(stmts, code_switch(alc, expr, ccases, false));

    if (opts->bUseStateNext) {
        o.str(opts->yynext).cstr(":");
        append_stmt(stmts, code_stmt_textraw(alc, o.flush()));
    }

    code->kind = CodeStmt::BLOCK;
    code->block.stmts = stmts;
    code->block.fmt = CodeBlock::RAW;
}

static void gen_yych_decl(const opt_t *opts, CodeStmt *code)
{
    if (opts->bEmitYYCh) {
        code->kind = CodeStmt::VAR;
        code->var.type = opts->yyctype.c_str();
        code->var.name = opts->yych.c_str();
        code->var.init = NULL;
    }
    else {
        code->kind = CodeStmt::EMPTY;
    }
}

static void gen_yyaccept_def(const opt_t *opts, CodeStmt *code, bool used_yyaccept)
{
    if (used_yyaccept) {
        code->kind = CodeStmt::VAR;
        code->var.type = "unsigned int";
        code->var.name = opts->yyaccept.c_str();
        code->var.init = "0";
    }
    else {
        code->kind = CodeStmt::EMPTY;
    }
}

static void gen_yymaxfill(Scratchbuf &o, const opt_t *opts, CodeStmt *code,
    size_t max_fill)
{
    if (opts->target == TARGET_CODE) {
        code->kind = CodeStmt::TEXT;
        o.cstr("#define YYMAXFILL ").u64(max_fill);
        code->text = o.flush();
    }
    else {
        code->kind = CodeStmt::EMPTY;
    }
}

static void gen_yymaxnmatch(Scratchbuf &o, const opt_t *opts, CodeStmt *code,
    size_t max_nmatch)
{
    if (opts->target == TARGET_CODE && opts->posix_syntax) {
        code->kind = CodeStmt::TEXT;
        o.cstr("#define YYMAXNMATCH ").u64(max_nmatch);
        code->text = o.flush();
    }
    else {
        code->kind = CodeStmt::EMPTY;
    }
}

static void render_line_info(std::ostream &o, uint32_t line, const std::string &fname,
    const opt_t *opts)
{
    if (opts->iFlag) return;

    switch (opts->lang) {
        case LANG_GO:
            // Go: //line <filename>:<line-number>
            o << "//line \"" << fname << "\":" << line << "\n";
            break;
        case LANG_C:
            // C/C++: #line <line-number> <filename>
            o << "#line " << line << " \"" << fname << "\"\n";
            break;
    }
}

void output_version_time(std::ostream &o, bool version, bool date)
{
    o << "/* Generated by re2c";
    if (version) {
        o << " " << PACKAGE_VERSION;
    }
    if (date) {
        o << " on ";
        time_t now = time (NULL);
        o.write (ctime (&now), 24);
    }
    o << " */";
}

/*
 * note [condition order]
 *
 * In theory re2c makes no guarantee about the order of conditions in
 * the generated lexer. Users should define condition type 'YYCONDTYPE'
 * and use values of this type with 'YYGETCONDITION' and 'YYSETCONDITION'.
 * This way code is independent of internal re2c condition numbering.
 *
 * However, it is possible to manually hardcode condition numbers and make
 * re2c generate condition dispatch without explicit use of condition names
 * (nested 'if' statements with '-b' or computed 'goto' table with '-g').
 * This code is syntactically valid (compiles), but unsafe:
 *     - change of re2c options may break compilation
 *     - change of internal re2c condition numbering may break runtime
 *
 * re2c has to preserve the existing numbering scheme.
 *
 * re2c warns about implicit assumptions about condition order, unless:
 *     - condition type is defined with 'types:re2c' or '-t, --type-header'
 *     - dispatch is independent of condition order: either it uses
 *       explicit condition names or there's only one condition and
 *       dispatch shrinks to unconditional jump
 */

static std::string output_cond_get(const opt_t *opts)
{
    return opts->cond_get + (opts->cond_get_naked ? "" : "()");
}

static CodeStmts *gen_cond_goto_binary(Scratchbuf &o, code_alc_t &alc,
    const std::vector<std::string> &conds, const opt_t *opts,
    size_t lower, size_t upper)
{
    CodeStmts *stmts = code_stmts(alc);
    CodeStmt *stmt = NULL;

    if (lower == upper) {
        o.cstr("goto ").str(opts->condPrefix).str(conds[lower]).cstr(";");
        stmt = code_stmt_text(alc, o.flush());
    }
    else {
        const size_t middle = lower + (upper - lower + 1) / 2;

        o.str(output_cond_get(opts)).cstr(" < ").u64(middle);
        CodeText if_cond = o.flush();

        CodeStmts *if_then = gen_cond_goto_binary(o, alc, conds, opts, lower, middle - 1);
        CodeStmts *if_else = gen_cond_goto_binary(o, alc, conds, opts, middle, upper);

        stmt = code_stmt_if_then_else(alc, if_cond, if_then, if_else);
    }

    append_stmt(stmts, stmt);
    return stmts;
}

static void gen_cond_goto(Scratchbuf &o, code_alc_t &alc, CodeStmt *code,
    const std::vector<std::string> &conds, const opt_t *opts, Msg &msg,
    bool warn_cond_ord, const loc_t &loc)
{
    const size_t ncond = conds.size();
    CodeStmts *stmts = code_stmts(alc);

    if (opts->target == TARGET_DOT) {
        for (size_t i = 0; i < ncond; ++i) {
            const std::string &cond = conds[i];
            o.cstr("0 -> ").str(cond).cstr(" [label=\"state=").str(cond).cstr("\"]");
            append_stmt(stmts, code_stmt_text(alc, o.flush()));
        }
    }
    else {
        if (opts->gFlag) {
            o.cstr("goto *").str(opts->yyctable).cstr("[").str(output_cond_get(opts)).cstr("];");
            append_stmt(stmts, code_stmt_text(alc, o.flush()));
        }
        else if (opts->sFlag) {
            warn_cond_ord &= ncond > 1;
            append_stmts(stmts, gen_cond_goto_binary(o, alc, conds, opts, 0, ncond - 1));
        }
        else {
            warn_cond_ord = false;

            o.str(output_cond_get(opts));
            CodeText expr = o.flush();

            CodeCases *ccases = code_cases(alc);
            for (size_t i = 0; i < ncond; ++i) {
                const std::string &cond = conds[i];

                o.str(opts->condEnumPrefix).str(cond);
                const char *caseval = o.flush();

                CodeStmts *body = code_stmts(alc);
                o.cstr("goto ").str(opts->condPrefix).str(cond).cstr(";");
                append_stmt(body, code_stmt_text(alc, o.flush()));

                append_case(ccases, code_case_string(alc, body, caseval));
            }

            append_stmt(stmts, code_switch(alc, expr, ccases, false));
        }

        // see note [condition order]
        warn_cond_ord &= opts->header_file.empty();
        if (warn_cond_ord) {
            msg.warn.condition_order(loc);
        }
    }

    code->kind = CodeStmt::BLOCK;
    code->block.stmts = stmts;
    code->block.fmt = CodeBlock::RAW;
}

static void gen_cond_table(Scratchbuf &o, code_alc_t &alc, CodeStmt *code,
    const std::vector<std::string> &conds, const opt_t *opts)
{
    const size_t ncond = conds.size();

    CodeStmts *stmts = code_stmts(alc);

    o.cstr("static void *").str(opts->yyctable).cstr("[").u64(ncond).cstr("] = {");
    append_stmt(stmts, code_stmt_text(alc, o.flush()));

    CodeStmts *block = code_stmts(alc);
    for (size_t i = 0; i < ncond; ++i) {
        o.cstr("&&").str(opts->condPrefix).str(conds[i]).cstr(",");
        append_stmt(block, code_stmt_text(alc, o.flush()));
    }
    append_stmt(stmts, code_block(alc, block, CodeBlock::INDENTED));

    o.cstr("};");
    append_stmt(stmts, code_stmt_text(alc, o.flush()));

    code->kind = CodeStmt::BLOCK;
    code->block.stmts = stmts;
    code->block.fmt = CodeBlock::RAW;
}

static bool oneline_if(const CodeIfTE *code, const opt_t *opts)
{
    const CodeStmt *first = code->if_code->head;
    return first
        && first->next == NULL
        && first->kind == CodeStmt::TEXT
        && opts->lang == LANG_C // Go requires braces
        && code->else_code == NULL
        && code->oneline;
}

void render_code_if_then_else(RenderContext &rctx, const CodeIfTE *code)
{
    std::ostringstream &os = rctx.os;
    const opt_t *opts = rctx.opts;
    const CodeStmt *first = code->if_code->head;

    os << indent(rctx.ind, opts->indString) << "if (" << code->if_cond << ") ";
    DASSERT(count_lines_text(code->if_cond) == 0);

    if (oneline_if(code, opts)) {
        os << first->text << std::endl;
        DASSERT(count_lines_text(first->text) == 0);
        ++rctx.line;
    }
    else {
        os << "{" << std::endl;
        ++rctx.line;
        for (const CodeStmt *s = first; s; s = s->next) {
            ++rctx.ind;
            render_code_stmt(rctx, s);
            --rctx.ind;
        }
        os << indent(rctx.ind, opts->indString) << "}";
        if (code->else_code) {
            if (code->else_cond) {
                os << " else if (" << code->else_cond << ") {" << std::endl;
                DASSERT(count_lines_text(code->else_cond) == 0);
            }
            else {
                os << " else {" << std::endl;
            }
            ++rctx.line;
            for (const CodeStmt *s = code->else_code->head; s; s = s->next) {
                ++rctx.ind;
                render_code_stmt(rctx, s);
                --rctx.ind;
            }
            os << indent(rctx.ind, opts->indString) << "}";
        }
        os << std::endl;
        ++rctx.line;
    }
}

void render_code_block(RenderContext &rctx, const CodeBlock *code)
{
    switch (code->fmt) {
        case CodeBlock::WRAPPED:
            rctx.os << indent(rctx.ind, rctx.opts->indString) << "{" << std::endl;
            ++rctx.line;
            ++rctx.ind;
            render_code_stmts(rctx, code->stmts);
            --rctx.ind;
            rctx.os << indent(rctx.ind, rctx.opts->indString) << "}" << std::endl;
            ++rctx.line;
            break;
        case CodeBlock::INDENTED:
            ++rctx.ind;
            render_code_stmts(rctx, code->stmts);
            --rctx.ind;
            break;
        case CodeBlock::RAW:
            render_code_stmts(rctx, code->stmts);
            break;
    }
}

static void render_code_var(RenderContext &rctx, const CodeVar *var)
{
    std::ostringstream &os = rctx.os;

    os << indent(rctx.ind, rctx.opts->indString);
    switch (rctx.opts->lang) {
        case LANG_C:
            os << var->type << " " << var->name;
            if (var->init) {
                os << " = " << var->init;
            }
            os << ";";
            break;
        case LANG_GO:
            if (var->init) {
                os << var->name << " := " << var->init;
            }
            else {
                os << "var " << var->name << " " << var->type;
            }
            break;
    }
    os << std::endl;
    ++rctx.line;
}

void render_code_stmt(RenderContext &rctx, const CodeStmt *code)
{
    std::ostringstream &os = rctx.os;
    const opt_t *opts = rctx.opts;
    const uint32_t ind = rctx.ind;
    uint32_t &line = rctx.line;

    switch (code->kind) {
        case CodeStmt::EMPTY:
            break;
        case CodeStmt::IF_THEN_ELSE:
            render_code_if_then_else(rctx, &code->ifte);
            break;
        case CodeStmt::SWITCH:
            render_code_switch(rctx, &code->swch);
            break;
        case CodeStmt::BLOCK:
            render_code_block(rctx, &code->block);
            break;
        case CodeStmt::TEXT_RAW:
            os << code->text << std::endl;
            line += count_lines_text(code->text) + 1;
            break;
        case CodeStmt::TEXT:
            os << indent(ind, opts->indString) << code->text << std::endl;
            line += count_lines_text(code->text) + 1;
            break;
        case CodeStmt::VERBATIM:
            os << code->text;
            line += count_lines_text(code->text);
            break;
        case CodeStmt::RAW:
            os.write(code->raw.data, static_cast<std::streamsize>(code->raw.size));
            for (const char *s = code->raw.data, *e = s + code->raw.size; s < e; ++s) {
                if (*s == '\n') ++line;
            }
            break;
        case CodeStmt::SKIP:
            output_skip(os, ind, opts);
            os << std::endl;
            ++line;
            break;
        case CodeStmt::PEEK:
            output_peek(os, ind, opts);
            ++line;
            break;
        case CodeStmt::BACKUP:
            output_backup(os, ind, opts);
            ++line;
            break;
        case CodeStmt::PEEK_SKIP:
            output_peek_skip(os, ind, opts);
            ++line;
            break;
        case CodeStmt::SKIP_PEEK:
            output_skip_peek(os, ind, opts);
            ++line;
            break;
        case CodeStmt::SKIP_BACKUP:
            output_skip_backup(os, ind, opts);
            ++line;
            break;
        case CodeStmt::BACKUP_SKIP:
            output_backup_skip(os, ind, opts);
            ++line;
            break;
        case CodeStmt::BACKUP_PEEK:
            output_backup_peek(os, ind, opts);
            ++line;
            break;
        case CodeStmt::BACKUP_PEEK_SKIP:
            output_backup_peek_skip(os, ind, opts);
            ++line;
            break;
        case CodeStmt::SKIP_BACKUP_PEEK:
            output_skip_backup_peek(os, ind, opts);
            ++line;
            break;
        case CodeStmt::LINE_INFO_INPUT:
            render_line_info(os, code->loc.line,
                rctx.msg.filenames[code->loc.file], opts);
            ++line;
            break;
        case CodeStmt::LINE_INFO_OUTPUT:
            render_line_info(os, rctx.line + 1, rctx.file, opts);
            ++line;
            break;
        case CodeStmt::VAR:
            render_code_var(rctx, &code->var);
            break;
        case CodeStmt::STAGS:
        case CodeStmt::MTAGS:
        case CodeStmt::YYMAXFILL:
        case CodeStmt::YYMAXNMATCH:
        case CodeStmt::YYCH:
        case CodeStmt::YYACCEPT:
        case CodeStmt::COND_ENUM:
        case CodeStmt::COND_GOTO:
        case CodeStmt::COND_TABLE:
        case CodeStmt::STATE_GOTO:
            assert(false); // must have been expanded before
            break;
    }
}

void render_code_stmts(RenderContext &rctx, const CodeStmts *code)
{
    for (const CodeStmt *s = code->head; s; s = s->next) {
        render_code_stmt(rctx, s);
    }
}

static bool oneline_case(const CodeCase *code)
{
    const CodeStmt *first = code->body->head;
    return first
        && first->next == NULL
        && first->kind == CodeStmt::TEXT;
}

void render_code_case(RenderContext &rctx, const CodeCase *code, bool defcase, bool noindent)
{
    std::ostringstream &os = rctx.os;
    const opt_t *opts = rctx.opts;
    const uint32_t ind = rctx.ind;
    const CodeStmt *first = code->body->head;

    if (defcase) {
        os << indent(ind, opts->indString) << "default:";
    }
    else if (code->kind == CodeCase::DEFAULT) {
        // TOOD: deduplicate "default" cases (requires adjusting test formatting)
        os << indent(ind, opts->indString) << "default: ";
    }
    else if (code->kind == CodeCase::NUMBER) {
        os << indent(ind, opts->indString) << "case " << code->number << ": ";
    }
    else if (code->kind == CodeCase::STRING) {
        os << indent(ind, opts->indString) << "case " << code->string << ": ";
    }
    else {
        const Enc &enc = opts->encoding;
        const bool ebcdic = enc.type() == Enc::EBCDIC;
        const size_t nranges = code->chars.nranges;
        const uint32_t *ranges = code->chars.ranges;

        for (uint32_t i = 0; i < nranges; ++i) {
            const uint32_t low = ranges[2 * i];
            const uint32_t upp = ranges[2 * i + 1];

            for (uint32_t c = low; c < upp; ++c) {
                os << indent(ind, opts->indString) << "case ";
                prtChOrHex(os, c, enc.szCodeUnit(), ebcdic, opts->target == TARGET_DOT);
                os << ":";
                if (opts->dFlag && ebcdic) {
                    const uint32_t c2 = enc.decodeUnsafe(c);
                    if (is_print(c2)) {
                        os << " /* " << static_cast<char>(c2) << " */";
                    }
                }

                const bool last_case = i == nranges - 1 && c == upp - 1;
                if (!last_case) {
                    if (opts->lang == LANG_GO) {
                        os << opts->indString << "fallthrough";
                    }
                    os << std::endl;
                    ++rctx.line;
                }
            }
        }
    }

    if (oneline_case(code)) {
        os << (noindent ? std::string() : opts->indString) << first->text << std::endl;
        ++rctx.line;
    }
    else {
        os << std::endl;
        ++rctx.line;
        for (const CodeStmt *s = first; s; s = s->next) {
            ++rctx.ind;
            render_code_stmt(rctx, s);
            --rctx.ind;
        }
    }
}

void render_code_switch(RenderContext &rctx, const CodeSwitch *code)
{
    std::ostringstream &os = rctx.os;
    const opt_t *opts = rctx.opts;
    const uint32_t ind = rctx.ind;

    os << indent(ind, opts->indString) << "switch (" << code->expr << ") {\n";
    ++rctx.line;

    CodeCase *first = code->cases->head; // default
    DASSERT(first);

    // TODO: remove this heuristic (requires fixing formatting in tests)
    const bool noindent = !code->impdef;

    if (code->impdef) {
        for (const CodeCase *c = first->next; c; c = c->next) {
            render_code_case(rctx, c, false, noindent);
        }
        render_code_case(rctx, first, true, noindent);
    }
    else {
        for (const CodeCase *c = first; c; c = c->next) {
            render_code_case(rctx, c, false, noindent);
        }
    }

    os << indent(ind, opts->indString) << "}\n";
    ++rctx.line;
}

static void fold_exprs(CodeStmts *stmts)
{
    CodeStmt *x, *y, *z;
    for (x = stmts->head; x; ) {
        // have three statements ahead
        if ((y = x->next) && (z = y->next)) {
            CodeStmt::Kind xk = x->kind;
            CodeStmt::Kind yk = y->kind;
            CodeStmt::Kind zk = z->kind;

            if (xk == CodeStmt::BACKUP && yk == CodeStmt::PEEK
                    && zk == CodeStmt::SKIP) {
                x->kind = CodeStmt::BACKUP_PEEK_SKIP;
                x->next = z->next;
                continue;
            }
            else if (xk == CodeStmt::SKIP && yk == CodeStmt::BACKUP
                    && zk == CodeStmt::PEEK) {
                x->kind = CodeStmt::SKIP_BACKUP_PEEK;
                x->next = z->next;
                continue;
            }
        }

        // have two statements ahead
        if ((y = x->next)) {
            CodeStmt::Kind xk = x->kind;
            CodeStmt::Kind yk = y->kind;

            if (xk == CodeStmt::PEEK && yk == CodeStmt::SKIP) {
                x->kind = CodeStmt::PEEK_SKIP;
                x->next = y->next;
                continue;
            }
            else if (xk == CodeStmt::SKIP && yk == CodeStmt::PEEK) {
                x->kind = CodeStmt::SKIP_PEEK;
                x->next = y->next;
                continue;
            }
            else if (xk == CodeStmt::SKIP && yk == CodeStmt::BACKUP) {
                x->kind = CodeStmt::SKIP_BACKUP;
                x->next = y->next;
                continue;
            }
            else if (xk == CodeStmt::BACKUP && yk == CodeStmt::PEEK) {
                x->kind = CodeStmt::BACKUP_PEEK;
                x->next = y->next;
                continue;
            }
            else if (xk == CodeStmt::BACKUP && yk == CodeStmt::SKIP) {
                x->kind = CodeStmt::BACKUP_SKIP;
                x->next = y->next;
                continue;
            }
        }

        x = x->next;
    }
}

void combine_stmt(CodegenContext &ctx, CodeStmt *code)
{
    switch (code->kind) {
        case CodeStmt::BLOCK:
            combine_stmts(ctx, code->block.stmts);
            break;
        // don't recurse into these because they have no skip/peek/backup
        case CodeStmt::EMPTY:
        case CodeStmt::IF_THEN_ELSE:
        case CodeStmt::SWITCH:
        case CodeStmt::TEXT:
        case CodeStmt::VERBATIM:
        case CodeStmt::RAW:
        case CodeStmt::TEXT_RAW:
        case CodeStmt::SKIP:
        case CodeStmt::PEEK:
        case CodeStmt::BACKUP:
        case CodeStmt::PEEK_SKIP:
        case CodeStmt::SKIP_PEEK:
        case CodeStmt::SKIP_BACKUP:
        case CodeStmt::BACKUP_SKIP:
        case CodeStmt::BACKUP_PEEK:
        case CodeStmt::BACKUP_PEEK_SKIP:
        case CodeStmt::SKIP_BACKUP_PEEK:
        case CodeStmt::LINE_INFO_INPUT:
        case CodeStmt::LINE_INFO_OUTPUT:
        case CodeStmt::VAR:
            break;
        case CodeStmt::STAGS:
            gen_tags(ctx.scratchbuf, code, ctx.allstags);
            break;
        case CodeStmt::MTAGS:
            gen_tags(ctx.scratchbuf, code, ctx.allmtags);
            break;
        case CodeStmt::YYMAXFILL:
            gen_yymaxfill(ctx.scratchbuf, ctx.opts, code, ctx.maxfill);
            break;
        case CodeStmt::YYMAXNMATCH:
            gen_yymaxnmatch(ctx.scratchbuf, ctx.opts, code, ctx.maxnmatch);
            break;
        case CodeStmt::YYCH:
            gen_yych_decl(ctx.opts, code);
            break;
        case CodeStmt::YYACCEPT:
            gen_yyaccept_def(ctx.opts, code, ctx.used_yyaccept);
            break;
        case CodeStmt::COND_ENUM:
            gen_cond_enum(ctx.scratchbuf, ctx.allocator, code, ctx.globopts,
                ctx.allcondnames);
            break;
        case CodeStmt::COND_GOTO:
            gen_cond_goto(ctx.scratchbuf, ctx.allocator, code, ctx.condnames,
                ctx.opts, ctx.msg, ctx.warn_cond_ord, ctx.loc);
            break;
        case CodeStmt::COND_TABLE:
            gen_cond_table(ctx.scratchbuf, ctx.allocator, code, ctx.condnames,
                ctx.opts);
            break;
        case CodeStmt::STATE_GOTO:
            gen_state_goto(ctx.scratchbuf, ctx.allocator, code, 0, ctx.fillidx,
                ctx.globopts);
            break;
    }
}

void combine_stmts(CodegenContext &ctx, CodeStmts *stmts)
{
    if (ctx.opts->input_api == INPUT_DEFAULT) {
        fold_exprs(stmts);
    }
    for (CodeStmt *x = stmts->head; x; x = x->next) {
        combine_stmt(ctx, x);
    }
}

Scratchbuf& Scratchbuf::u32_hex(uint32_t u, const opt_t *opts)
{
    prtHex(os, u, opts->encoding.szCodeUnit());
    return *this;
}

Scratchbuf& Scratchbuf::u32_width(uint32_t u, int width)
{
    os << std::setw(width);
    os << u;
    return *this;
}

inline const char *Scratchbuf::flush()
{
    const size_t len = os.str().length();
    char *e = alc.alloct<char>(len + 1);
    memcpy(e, os.str().c_str(), len);
    e[len] = 0;
    os.str("");
    return e;
}

} // namespace re2c
